W
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/simulations/other radon sims/")#
#
library(lme4)#
library(plyr)#
library(inline)#
library(RcppEigen)#
library(MASS)#
library(nortest)#
library(inline)#
library(xtable)#
#
REMLmodels <- c("exp_exp_REMLmodels.RDS", "exp_norm_REMLmodels.RDS",  "exp_t_REMLmodels.RDS", #
"norm_exp_REMLmodels.RDS", "norm_norm_REMLmodels.RDS", "norm_t_REMLmodels.RDS",#
"t_exp_REMLmodels.RDS", "t_norm_REMLmodels.RDS", "t_t_REMLmodels.RDS")#
#
source("../functions/normality_functions.R")#
source("../functions/utility_functions.R")
rm(list=ls())
ls()
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/simulations/other radon sims/")#
#
library(lme4)#
library(plyr)#
library(inline)#
library(RcppEigen)#
library(MASS)#
library(nortest)#
library(inline)#
library(xtable)#
#
REMLmodels <- c("exp_exp_REMLmodels.RDS", "exp_norm_REMLmodels.RDS",  "exp_t_REMLmodels.RDS", #
"norm_exp_REMLmodels.RDS", "norm_norm_REMLmodels.RDS", "norm_t_REMLmodels.RDS",#
"t_exp_REMLmodels.RDS", "t_norm_REMLmodels.RDS", "t_t_REMLmodels.RDS")#
#
source("../functions/normality_functions.R")#
source("../functions/utility_functions.R")
ls()
load("residuals/minconf_ordered_level2_residuals_sige2_sigb1.RData")
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/simulations/continuous slope radon sims/")
load("residuals/minconf_ordered_level2_residuals_sige2_sigb1.RData")
dist.combos <- t(sapply(strsplit(REMLmodels, "_"), FUN = function(x) return(c(error = x[1], `ranef` = x[2]))))
ls()
b0.mcr          <- test.simulation.results(sims = b0.mcresid, settings = dist.combos)
b0.mcr.vmx      <- test.simulation.results(sims = b0.mcresid.vmx, settings = dist.combos)
print.format(b0.mcr, ranef = TRUE)
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/minconfounded_chapter/")
source("../simulations/functions/cpp_functions.R")
Data for the continuous random slope example#
radon <- read.csv("data/radon_for_sims.csv")#
#
# Simulated models under normality situation#
normsims <- readRDS("../simulations/continuous slope radon sims/sim_models/sige2_sigb1/norm_norm_REMLmodels.RDS")#
#
# the fitted model#
fm <- normsims[[1]]#
#
rm(normsims)
BlockZ <- function(object) {#
  Z <- getME(object, "Z")#
  grp.size <- table(object@flist)#
  ngrps <- length(grp.size)#
  nranef <- dim(ranef(object)[[1]])[2]#
  base.ord <- seq(from = 1, by = ngrps, length.out = nranef)#
  ord <- base.ord + rep(0:(ngrps - 1), each = nranef)#
  perm.mat <- t(as(ord, "pMatrix"))#
  return(Z %*% perm.mat)#
}#
#
mcrotate <- function(A, B) {#
  r <- rankMatrix(B)#
  B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:r]#
  Tr <- B.svd$u[, 1:r]#
  A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u#
  return(W)#
}#
#
ggfluctuation <- function (table, type = "size", floor = 0, ceiling = max(table$freq, #
    na.rm = TRUE)) #
{#
    .Deprecated()#
    if (is.table(table)) #
        table <- as.data.frame(t(table))#
    oldnames <- names(table)#
    names(table) <- c("x", "y", "result")#
    table <- transform(table, x = as.factor(x), y = as.factor(y), #
        freq = result)#
    if (type == "size") {#
        table <- transform(table, freq = sqrt(pmin(freq, ceiling)/ceiling), #
            border = ifelse(is.na(freq), "grey90", ifelse(freq > #
                ceiling, "grey30", "grey50")))#
        table[is.na(table$freq), "freq"] <- 1#
        table <- subset(table, freq * ceiling >= floor)#
    }#
    if (type == "size") {#
        nx <- length(levels(table$x))#
        ny <- length(levels(table$y))#
        p <- ggplot(table, aes_string(x = "x", y = "y", height = "freq", #
            width = "freq", fill = "border")) + geom_tile(colour = "white") + #
            scale_fill_identity() + theme(aspect.ratio = ny/nx)#
    }#
    else {#
        p <- ggplot(table, aes_string(x = "x", y = "y", fill = "freq")) + #
            geom_tile(colour = "white") + scale_fill_gradient2(expression(sign(w[ij])*sqrt(abs(w[ij])))#
, low = "red", mid="white", high = "blue")#
    }#
    p$xlabel <- oldnames[1]#
    p$ylabel <- oldnames[2]#
    p#
}
Extract necessary components of the fitted model#
y <- fm@y#
X <- getME(fm, "X")#
Z <- BlockZ(fm) #
#
n <- nrow(X)#
p <- ncol(X)#
ngrps <- unname( summary(fm)@ngrps )#
vc <- VarCorr(fm)#
Di <- Diagonal(x = c(vc[[1]], vc[[2]])) / (unname(attr(vc, "sc")))^2#
D  <- kronecker( Diagonal(ngrps), Di )#
#
Aslot <- .mod@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))#
#
pzdl <- P %*% Z %*% D %*% L.slope#
A.slope <-  crossprod( pzdl )#
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope
Aslot <- fm@A # ZDZ'
zdzt <- crossprod( fm@A )
fc <- diag(ginv(as.matrix(B.slope)) %*% A.slope)
fc
sort(fc)
sort(fc decreasing = T)
sort(fc, decreasing = T)
cumsum(sort(fc, decreasing = T))
sum(fc) - cumsum(sort(fc, decreasing = T))
(sum(fc) - cumsum(sort(fc, decreasing = T)) ) / sum(fc)
length(fc)
W.slope <- as.matrix( mcrotate(A = A.slope[order(fc),], B = B.slope[order(fc),]) )
t(W.slope) %*% ranef(fm)[[1]][,2]
qqnorm(t(W.slope) %*% ranef(fm)[[1]][,2])
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope) )
qqnorm(t(W.slope) %*% ranef(fm)[[1]][,2])
W.slope <- as.matrix( mcrotate(A = A.slope[order(fc),], B = B.slope[order(fc),]) )
qqnorm(t(W.slope) %*% ranef(fm)[[1]][order(fc),2])
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope) )
qqnorm(t(W.slope) %*% ranef(fm)[[1]][,2])
B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:79]#
  Tr <- B.svd$u[, 1:79]
B.svd <- svd(B.slope)#
  Cr.diag <- B.svd$d[1:79]#
  Tr <- B.svd$u[, 1:79]
A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A.slope %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u
str(A.star.svd)
mean(A.star.svd)
mean(A.star.svd$d)
mean(fc)
.1*32
.1*.32
qqnorm(t(W) %*% ranef(fm)[[1]][,2])
B.svd <- svd(B.slope)#
  Cr.diag <- B.svd$d[1:50]#
  Tr <- B.svd$u[, 1:50]
A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A.slope %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u
qqnorm(t(W) %*% ranef(fm)[[1]][,2])
image(W)
image(t(W))
W.slope <- W
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )[order(fc)]
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
W.slope <- as.matrix(W)
W.slope <- as.matrix( mcrotate(A = A.slope[order(fc),], B = B.slope[order(fc),]) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
W.slope <- as.matrix(W)
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )[order(fc)]
rslope.var <- diag(B.slope)
reordered.Wt.slope <- Wt.slope[, order(rslope.var)]
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(rslope.var)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
as.table(reordered.Wt.slope.tform)
names(as.table(reordered.Wt.slope.tform))
colnames(as.table(reordered.Wt.slope.tform))
colnames(as.table(reordered.Wt.slope.tform)) -> j
table(radon$county.name)
as.data.frame(table(radon$county.name))
merge(x = j, y = as.data.frame(table(radon$county.name)), by.y = "Var1")
str(j)
j <- data.frame(j)
head(j)
merge(x = j, y = as.data.frame(table(radon$county.name)), by.x="j", by.y = "Var1")
head(as.data.frame(table(radon$county.name)))
j
colnames(as.table(reordered.Wt.slope.tform)) -> j
j
as.data.frame(table(radon$county.name))[j, 1]
A.star.svd$d
r <- rankMatrix(B)
B <- B.slope
r <- rankMatrix(B)
B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:r]#
  Tr <- B.svd$u[, 1:r]
Cr.diag[-c(1:30)]
mean(Cr.diag[-c(1:30)])
Cr.diag <- Cr.diag[-c(1:30)]
Tr <- Tr[,-c(1:30)]
dim(Tr)
length(Cr.diag)
A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u
dim(A)
A <- A.slope
A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u
W.slope <- as.matrix(W)
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )
reordered.Wt.slope <- Wt.slope[, order(rslope.var)]
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(rslope.var)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
dim(A)
dim(B)
unique(radon$county.name)
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
table(radon$county.name)
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
dim(W.slope)
all.equal(W, W.slope)
all.equal(as.matrix(W), W.slope)
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )
rslope.var <- diag(B.slope)#
#
reordered.Wt.slope <- Wt.slope[, order(rslope.var)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(rslope.var)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
reordered.Wt.vmx.slope
image(Wt.slope)
Wt.slope %*% ranef(fm)[[1]][,2]
qqnorm(Wt.slope %*% ranef(fm)[[1]][,2])
qqline(Wt.slope %*% ranef(fm)[[1]][,2])
ad.test(Wt.slope %*% ranef(fm)[[1]][,2])
cvm.test(Wt.slope %*% ranef(fm)[[1]][,2])
lillie.test(Wt.slope %*% ranef(fm)[[1]][,2])
r <- rankMatrix(B)#
  B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:r]#
  Tr <- B.svd$u[, 1:r]
A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )
A.star.svd <- svd( A.star )
A.star.svd$d
dim(A.star.svd$u)
W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u[,-c(1:30)]
dim(W)
qqnorm(t(W) %*% ranef(fm)[[1]][,2])
qqline(t(W) %*% ranef(fm)[[1]][,2])
W.slope -> W
W.slope -> as.matrix(W)
W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u[,-c(1:30)]
W.slope <- as.matrix(W)
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )
dim(Wt.slope)
r
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- as.character(1:82)
dim(Wt.slope)
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- as.character(1:51)
rslope.var <- diag(B.slope)
reordered.Wt.slope <- Wt.slope[, order(rslope.var)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(rslope.var)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))#
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
fc
length(fc)
dim(B.slope)
reordered.Wt.slope <- Wt.slope[, order(fc)]
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
order(fc)
sort(fc)
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 70
seq_len(70)
seq(81, length.out = s)
seq(81, length.out = s, by = -1)
dim(W)
jw <- W
mcrotate <- function(A, B, s) {#
  r <- rankMatrix(B)#
  B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:r]#
  Tr <- B.svd$u[, 1:r]#
  A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  index <- seq(r, length.out = s, by = -1)#
  index <- sort(index)#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u[,index]#
  return(W)#
}
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = 51) )
dim(W.slope)
all.equal(jw, W.slope)
all.equal(as.matrix(jw), W.slope)
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = 81) )
L.int <- kronecker(Diagonal(ngrps), c(1, 0))
pzdl <- P %*% Z %*% D %*% L.int#
A.int <-  crossprod( pzdl )#
B.int <- t(L.int) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.int
W.int   <- as.matrix( mcrotate(A = A.int, B = B.int, s = 81) )
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = 81) )
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- as.character(1:81)
dim(Wt.slope)
s <- 81 # length of rotated residual vector#
W.int   <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- as.character(1:s)
rslope.var <- diag(B.slope)
reordered.Wt.slope <- Wt.slope[, order(rslope.var)]
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(rslope.var)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
reordered.Wt.slope <- Wt.slope[, order(fc)]
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
reordered.Wt.slope <- Wt.slope[, order(fc, decreasing = TRUE)]
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc, decreasing = TRUE)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
W.vmx.int<- varimax( W.int, normalize = FALSE )$loadings
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
reordered.Wt.int <- Wt.int[, order(rint.var)]#order(fc, decreasing = TRUE)]
reordered.Wt.vmx.int <- Wt.vmx.int[, order(rint.var) #order(fc, decreasing = TRUE)]
]
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 71 # length of rotated residual vector
For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(rint.var)] #order(fc, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(rint.var)] #order(fc, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
reordered.Wt.int <- Wt.int[, order(fc, decreasing = TRUE)]
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc, decreasing = TRUE)]
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines
"))
s <- 71 # length of rotated residual vector#
#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 61 # length of rotated residual vector#
#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 51 # length of rotated residual vector#
#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 30 # length of rotated residual vector#
#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)
s <- 81 # length of rotated residual vector
For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(f.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 70 # length of rotated residual vector#
#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))#
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 60 # length of rotated residual vector#
#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))#
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 60 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- as.character(1:s)#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))#
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
s <- 60 # length of rotated residual vector
For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- as.character(1:s)
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))#
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
