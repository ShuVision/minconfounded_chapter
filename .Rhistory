m0 <- lm(x~qnorm(cdf(x)))
qplot(x,  resid(m0)) + geom_hline(aes(yintercept=0)) + geom_smooth(method="lm")
x <- rnorm(100)
m0 <- lm(x~qnorm(cdf(x)))
qplot(x,  resid(m0)) + geom_hline(aes(yintercept=0)) + geom_smooth(method="lm")
m0 <- lm(x~qnorm(cdf(x)))
m0.lower <- lm(env$lower~qnorm(cdf(env$lower)))
m0.upper <- lm(env$upper~qnorm(cdf(env$upper)))
x
m0.lower
m0.lower <- resid(lm(env$lower~qnorm(cdf(env$lower))))
m0.upper <- resid(lm(env$upper~qnorm(cdf(env$upper))))
m0.lower
env
qplot(x,  resid(m0)) + geom_hline(aes(yintercept=0)) + geom_smooth(method="lm") + geom_line(x, m0.lower, linetype=3) + geom_line(x, m0.upper, linetype=3)
qplot(x,  resid(m0)) + geom_hline(aes(yintercept=0)) + geom_smooth(method="lm") + geom_line(x = x, y = m0.lower, linetype=3) + geom_line(x = x, y = m0.upper, linetype=3)
D <- data.frame(m0.lower, m0.upper, m0)
m0 <- resid(lm(x~qnorm(cdf(x))))
D <- data.frame(m0.lower, m0.upper, m0)
head(D)
D
library(inline)
library(RcppEigen)
Matrix addition/subtraction#
subCpp <- '#
typedef Eigen::Map<Eigen::MatrixXd> MapMatd;#
const MapMatd B(as<MapMatd>(BB));#
const MapMatd C(as<MapMatd>(CC));#
return wrap(B - C);#
'#
#
cxxmatsub <- cxxfunction(signature(BB = "matrix", CC = "matrix"),#
subCpp, plugin = "RcppEigen")
Matrix multiplication#
prodCpp <- '#
using Eigen::Map;#
using Eigen::MatrixXd;#
const Map<MatrixXd> A(as<Map<MatrixXd> >(AA));#
const Map<MatrixXd> B(as<Map<MatrixXd> >(BB));#
return wrap( A * B );#
'#
#
cxxprod <- cxxfunction(signature(AA = "matrix", BB = "matrix"),#
prodCpp, plugin = "RcppEigen")
.Call("eigen_version", FALSE)
install.packages("RcppEigen")
library(RcppEigen)
.Call("eigen_version", FALSE)
Matrix multiplication#
prodCpp <- '#
using Eigen::Map;#
using Eigen::MatrixXd;#
const Map<MatrixXd> A(as<Map<MatrixXd> >(AA));#
const Map<MatrixXd> B(as<Map<MatrixXd> >(BB));#
return wrap( A * B );#
'#
#
cxxprod <- cxxfunction(signature(AA = "matrix", BB = "matrix"),#
prodCpp, plugin = "RcppEigen")
setwd("~/Documents/Thesis/Dissertation/New-resid-manuscript/simulations/march/models")
list.dirs("~/Documents/Thesis/Dissertation/New-resid-manuscript/simulations/march/models")
list.dirs("~/Documents/Thesis/Dissertation/New-resid-manuscript/simulations/march")
list.dirs("~/Documents/Thesis/Dissertation/New-resid-manuscript/simulations/")
library(lme4)
version(lme4)
sessionInfo()
install.packages("lme4")
library(lme4)
sessionInfo()
library(lme4)
library(HLMdiag)
help(package=HLMdiag)
library(HLMdiag)
install.packages("lme4")
library(HLMdiag)
help(package=HLMdiag)
q("no")
73.59 + 85.59
(73.59 + 85.59)/2
Preliminaries#
library(lme4)#
library(arm)       # for nicer print outs from lmer#
library(ggplot2)#
library(nortest)   # for tests of normality#
library(boot)      # for simulation envelopes#
#
### Reading in the radon data provided by Gelman and Hill (2007)#
srrs2 <- read.table ("/Users/adam/Documents/Thesis/Gelman and Hill 2007/ARM_Data/radon/srrs2.dat", header=T, sep=",")#
#
## Restricting attention to Minnesota#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
basement <- floor#
#
## Getting county index variable#
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}#
#
## Reading the county-level data#
srrs2.fips <- srrs2$stfips*1000 + srrs2$cntyfips#
cty <- read.table ("/Users/adam/Documents/Thesis/Gelman and Hill 2007/Book_Codes/Ch.12/cty.dat", header=T, sep=",")#
usa.fips <- 1000*cty[,"stfips"] + cty[,"ctfips"]#
usa.rows <- match (unique(srrs2.fips[mn]), usa.fips)#
uranium <- cty[usa.rows,"Uppm"]#
u <- log (uranium)#
uranium <- u[county]#
### Fitting a model with random intercept for county and #
### random slope for basement.#
fm <- lmer(log.radon ~ basement + uranium + (basement | county), REML = FALSE)#
lev1 <- resid(fm)#
rint <- ranef(fm)[[1]][,1]#
rslope <- ranef(fm)[[1]][,2]#
#
bmat <- matrix(t(ranef(fm)[[1]]), ncol=1)
ggplot(data.frame(rint), aes(sample = rint))
ggplot(data.frame(rint), aes(sample = rint)) + stat_qq()
ggplot(data.frame(rint), aes(sample = rint)) + #
	geom_abline(intercept = HLMdiag:::qqlineInfo(rint)[1], #
              slope = HLMdiag:::qqlineInfo(rint)[2], colour = I("grey60")) + #
	stat_qq()
ggplot(data.frame(rint), aes(sample = rint)) + #
	geom_abline(intercept = HLMdiag:::qqlineInfo(rint)[1], #
              slope = HLMdiag:::qqlineInfo(rint)[2], colour = I("grey60")) + #
	stat_qq() + #
	geom_ribbon(aes(x = naive.rint.qq$x, ymin = naive.rint.env$lower, ymax = naive.rint.env$upper), alpha = .2) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles")
sim_env <- function(x, conf = .95){#
  n <- length(x)#
  P <- ppoints(x)#
  z <- qnorm(P)#
  a <- as.numeric(HLMdiag:::qqlineInfo(x)[1])#
  b <- as.numeric(HLMdiag:::qqlineInfo(x)[2])#
  zz <- qnorm(1 - (1 - conf)/2)#
  SE <- (b/dnorm(z)) * sqrt(P * (1 - P)/n)#
  fit.value <- a + b * z#
  upper <- fit.value + zz * SE#
  lower <- fit.value - zz * SE#
  return(data.frame(lower, upper))#
}
naive.rint.env <- sim_env(rint)#
naive.rint.qq <- qqnorm(rint, plot.it = FALSE)#
naive.rint.qq <- lapply(naive.rint.qq, sort)
ggplot(data.frame(rint), aes(sample = rint)) + #
	geom_abline(intercept = HLMdiag:::qqlineInfo(rint)[1], #
              slope = HLMdiag:::qqlineInfo(rint)[2], colour = I("grey60")) + #
	stat_qq() + #
	geom_ribbon(aes(x = naive.rint.qq$x, ymin = naive.rint.env$lower, ymax = naive.rint.env$upper), alpha = .2) + #
	xlab("Normal Quantiles") + ylab("Sample Quantiles") + #
	ylim(-.2, .2) + #
	theme_bw()
ggplot(data.frame(rint), aes(sample = rint)) + #
	geom_abline(intercept = HLMdiag:::qqlineInfo(rint)[1], #
              slope = HLMdiag:::qqlineInfo(rint)[2], colour = I("grey60")) + #
	stat_qq() +
xlab("Normal Quantiles") + ylab("Sample Quantiles") + #
	ylim(-.2, .2) + #
	theme_bw()
ggplot(data.frame(rslope), aes(sample = rslope)) +
stat_qq() + #
	geom_ribbon(aes(x = naive.rint.qq$x, ymin = naive.rint.env$lower, ymax = naive.rint.env$upper), alpha = .2) +#
	xlab("Normal Quantiles") + ylab("Sample Quantiles") + #
	ylim(-.6, .6) + #
	theme_bw()
ggplot(data.frame(rslope), aes(sample = rslope)) + #
	geom_abline(intercept = HLMdiag:::qqlineInfo(rslope)[1], #
              slope = HLMdiag:::qqlineInfo(rslope)[2], colour = I("grey60")) + #
	stat_qq() +
xlab("Normal Quantiles") + ylab("Sample Quantiles") + #
	ylim(-.6, .6) + #
	theme_bw()
Preliminaries#
library(lme4)#
library(arm)       # for nicer print outs from lmer#
library(ggplot2)#
library(nortest)   # for tests of normality#
library(RcppEigen)#
library(inline)#
library(grid)#
#
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/minconfounded_chapter/")#
#
source("../simulations/functions/cpp_functions.R")#
#
# Data for the continuous random slope example#
radon <- read.csv("data/radon_for_sims.csv")#
#
# Simulated models under normality situation#
normsims <- readRDS("../simulations/continuous slope radon sims/sim_models/sige2_sigb1/norm_norm_REMLmodels.RDS")#
#
# the fitted model#
fm <- normsims[[1]]#
#
rm(normsims)#
#
#-------------------------------------------------------------------------------#
# Calculating the rotated residuals#
#-------------------------------------------------------------------------------#
#
BlockZ <- function(object) {#
  Z <- getME(object, "Z")#
  grp.size <- table(object@flist)#
  ngrps <- length(grp.size)#
  nranef <- dim(ranef(object)[[1]])[2]#
  base.ord <- seq(from = 1, by = ngrps, length.out = nranef)#
  ord <- base.ord + rep(0:(ngrps - 1), each = nranef)#
  perm.mat <- t(as(ord, "pMatrix"))#
  return(Z %*% perm.mat)#
}#
#
mcrotate <- function(A, B, s) {#
  r <- rankMatrix(B)#
  B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:r]#
  Tr <- B.svd$u[, 1:r]#
  A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  index <- seq(r, length.out = s, by = -1)#
  index <- sort(index)#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u[,index]#
  return(W)#
}#
#
ggfluctuation <- function (table, type = "size", floor = 0, ceiling = max(table$freq, #
    na.rm = TRUE)) #
{#
    .Deprecated()#
    if (is.table(table)) #
        table <- as.data.frame(t(table))#
    oldnames <- names(table)#
    names(table) <- c("x", "y", "result")#
    table <- transform(table, x = as.factor(x), y = as.factor(y), #
        freq = result)#
    if (type == "size") {#
        table <- transform(table, freq = sqrt(pmin(freq, ceiling)/ceiling), #
            border = ifelse(is.na(freq), "grey90", ifelse(freq > #
                ceiling, "grey30", "grey50")))#
        table[is.na(table$freq), "freq"] <- 1#
        table <- subset(table, freq * ceiling >= floor)#
    }#
    if (type == "size") {#
        nx <- length(levels(table$x))#
        ny <- length(levels(table$y))#
        p <- ggplot(table, aes_string(x = "x", y = "y", height = "freq", #
            width = "freq", fill = "border")) + geom_tile(colour = "white") + #
            scale_fill_identity() + theme(aspect.ratio = ny/nx)#
    }#
    else {#
        p <- ggplot(table, aes_string(x = "x", y = "y", fill = "freq")) + #
            geom_tile(colour = "white") + scale_fill_gradient2(expression(sign(w[ij])*sqrt(abs(w[ij])))#
, low = "red", mid="white", high = "blue")#
    }#
    p$xlabel <- oldnames[1]#
    p$ylabel <- oldnames[2]#
    p#
}#
#
### Extract necessary components of the fitted model#
y <- fm@y#
X <- getME(fm, "X")#
Z <- BlockZ(fm) #
#
n <- nrow(X)#
p <- ncol(X)#
ngrps <- unname( summary(fm)@ngrps )#
vc <- VarCorr(fm)#
Di <- Diagonal(x = c(vc[[1]], vc[[2]])) / (unname(attr(vc, "sc")))^2#
D  <- kronecker( Diagonal(ngrps), Di )#
#
Aslot <- fm@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.int <- kronecker(Diagonal(ngrps), c(1, 0))#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))#
#
pzdl <- P %*% Z %*% D %*% L.slope#
A.slope <-  crossprod( pzdl )#
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope#
#
pzdl <- P %*% Z %*% D %*% L.int#
A.int <-  crossprod( pzdl )#
B.int <- t(L.int) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.int#
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)#
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)
s <- 81 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
plot(as.numeric(reordered.Wt.int), as.numeric(reordered.Wt.int.tform))
abline(a=0,b=1)
summary(reordered.Wt.int)
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
dim(Wt.int)
s <- 81 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- as.character(1:s)
dim(Wt.int)
seq_len(nrows(Wt.int))
seq_len(nrow(Wt.int))
s <- 82 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings
s <- 81 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))
Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
mcrotate
rankMatrix(B.slope)
seq(81, length.out=81, by=-1)
s
r
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
s = 60
For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines"))#
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
mcrotate
B
rankMatrix(B.int)
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
paste("RandomIntercept_s", s, sep="")
getwd()
ggsave(filename = paste("RandomIntercept_s", s, ".pdf", sep=""), width = 5,  height = 5, units = "in")
ggsave(filename = paste("RandomIntercept_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")
ggsave(filename = paste("RandomIntercept_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
s
s <- 80 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))#
#
ggsave(filename = paste("RandomIntercept_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")#
#
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))#
#
ggsave(filename = paste("RandomIntercept_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
s <- 70 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))#
#
ggsave(filename = paste("RandomIntercept_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")#
#
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))#
#
ggsave(filename = paste("RandomIntercept_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
s <- 50 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))#
#
ggsave(filename = paste("RandomIntercept_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")#
#
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))#
#
ggsave(filename = paste("RandomIntercept_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
s <- 80 # length of rotated residual vector
s <- 80 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))#
 ggsave(filename = paste("RandomSlope_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")#
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))#
ggsave(filename = paste("RandomSlope_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
s <- 70 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))#
 ggsave(filename = paste("RandomSlope_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")#
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))#
ggsave(filename = paste("RandomSlope_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
s <- 60 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))#
 ggsave(filename = paste("RandomSlope_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")#
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))#
ggsave(filename = paste("RandomSlope_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
s <- 50 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))#
 ggsave(filename = paste("RandomSlope_s", s, ".pdf", sep=""), width = 8,  height = 8, units = "in")#
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))#
ggsave(filename = paste("RandomSlope_s", s, "_varimax.pdf", sep=""), width = 8,  height = 8, units = "in")
fc.int
sum(fc.int)
sum(fc.slope)
mean(fc.slope)
mean(fc.int)
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/simulations/other radon sims/")
Loading data#
## Reading in the radon data provided by Gelman and Hill (2007)#
srrs2 <- read.table ("srrs2.dat", header=T, sep=",")#
#
## Restricting attention to Minnesota#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
basement <- floor#
#
## Getting county index variable#
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}#
#
## Reading the county-level data#
srrs2.fips <- srrs2$stfips*1000 + srrs2$cntyfips#
cty <- read.table ("cty.dat", header=T, sep=",")#
usa.fips <- 1000*cty[,"stfips"] + cty[,"ctfips"]#
usa.rows <- match (unique(srrs2.fips[mn]), usa.fips)#
uranium <- cty[usa.rows,"Uppm"]#
u <- log (uranium)#
uranium <- u[county]
fitted model using ML#
(fm.ml <- lmer(log.radon ~ basement + uranium + (1 | county) + (0 + basement | county), REML = FALSE))
head(fm.ml@frame)
fm <- fm.ml
y <- fm@y#
X <- getME(fm, "X")#
Z <- BlockZ(fm) #
#
n <- nrow(X)#
p <- ncol(X)#
ngrps <- unname( summary(fm)@ngrps )#
vc <- VarCorr(fm)#
Di <- Diagonal(x = c(vc[[1]], vc[[2]])) / (unname(attr(vc, "sc")))^2#
D  <- kronecker( Diagonal(ngrps), Di )#
#
Aslot <- fm@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.int <- kronecker(Diagonal(ngrps), c(1, 0))#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))#
#
pzdl <- P %*% Z %*% D %*% L.slope#
A.slope <-  crossprod( pzdl )#
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope#
#
pzdl <- P %*% Z %*% D %*% L.int#
A.int <-  crossprod( pzdl )#
B.int <- t(L.int) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.int#
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)#
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)
s <- 50 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings
dim(W.int)
s <- 85 # length of rotated residual vector
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )
s <- rankMatrix(B.int) # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings
dim(W.int)
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )
county.name
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( county.name )
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
s <- 70 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( county.name )
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
fc.int
mean(fc.int)
mean(fc.slope)
summary(fc.int)
summary(fc.slope)
17700 * .02
(17700 * .06)
52000-17701
34299 * .04
34299 * .09
34299 * .13
34299 * .13 + (17700 * .09)
6051.87 * 30
fm
plot(ranef(fm))
plot(ranef(fm), pch=16)
plot(ranef(fm), pch=16)
radon <- read.csv("data/radon_for_sims.csv")
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/minconfounded_chapter/")#
#
source("../simulations/functions/cpp_functions.R")
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/simulations/other radon sims/")
Loading data#
## Reading in the radon data provided by Gelman and Hill (2007)#
srrs2 <- read.table ("srrs2.dat", header=T, sep=",")#
#
## Restricting attention to Minnesota#
mn <- srrs2$state=="MN"#
radon <- srrs2$activity[mn]#
log.radon <- log (ifelse (radon==0, .1, radon))#
floor <- srrs2$floor[mn]       # 0 for basement, 1 for first floor#
n <- length(radon)#
y <- log.radon#
basement <- floor#
#
## Getting county index variable#
county.name <- as.vector(srrs2$county[mn])#
uniq <- unique(county.name)#
J <- length(uniq)#
county <- rep (NA, J)#
for (i in 1:J){#
  county[county.name==uniq[i]] <- i#
}#
#
## Reading the county-level data#
srrs2.fips <- srrs2$stfips*1000 + srrs2$cntyfips#
cty <- read.table ("cty.dat", header=T, sep=",")#
usa.fips <- 1000*cty[,"stfips"] + cty[,"ctfips"]#
usa.rows <- match (unique(srrs2.fips[mn]), usa.fips)#
uranium <- cty[usa.rows,"Uppm"]#
u <- log (uranium)#
uranium <- u[county]
(fm.ml <- lmer(log.radon ~ basement + uranium + (1 | county) + (0 + basement | county), REML = FALSE))
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/minconfounded_chapter/")
radon <- read.csv("data/radon_for_sims.csv")
head(radon)
head(fm.ml@frame)
head(cbind(fm.ml@frame, county.name))
library(stringr)
head(cbind(fm.ml@frame, str_trim(county.name)))
str(cbind(fm.ml@frame, str_trim(county.name)))
head(data.frame(fm.ml@frame, county.name = str_trim(county.name)))
full.radon <- data.frame(fm.ml@frame, county.name = str_trim(county.name))
dim(full.radon)
head(full.radon)
args(write.table)
write.csv(full.radon, "data/original_radon.csv", row.names = FALSE)
radon <- read.csv("data/original_radon.csv")
head(radon)
fm <- lmer(log.radon ~ basement + uranium + (baement | county), data = radon)
fm <- lmer(log.radon ~ basement + uranium + (basement | county), data = radon)
fm
BlockZ <- function(object) {#
  Z <- getME(object, "Z")#
  grp.size <- table(object@flist)#
  ngrps <- length(grp.size)#
  nranef <- dim(ranef(object)[[1]])[2]#
  base.ord <- seq(from = 1, by = ngrps, length.out = nranef)#
  ord <- base.ord + rep(0:(ngrps - 1), each = nranef)#
  perm.mat <- t(as(ord, "pMatrix"))#
  return(Z %*% perm.mat)#
}#
#
mcrotate <- function(A, B, s) {#
  r <- rankMatrix(B)#
  B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:r]#
  Tr <- B.svd$u[, 1:r]#
  A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  index <- seq(r, length.out = s, by = -1)#
  index <- sort(index)#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u[,index]#
  return(W)#
}#
#
ggfluctuation <- function (table, type = "size", floor = 0, ceiling = max(table$freq, #
    na.rm = TRUE)) #
{#
    .Deprecated()#
    if (is.table(table)) #
        table <- as.data.frame(t(table))#
    oldnames <- names(table)#
    names(table) <- c("x", "y", "result")#
    table <- transform(table, x = as.factor(x), y = as.factor(y), #
        freq = result)#
    if (type == "size") {#
        table <- transform(table, freq = sqrt(pmin(freq, ceiling)/ceiling), #
            border = ifelse(is.na(freq), "grey90", ifelse(freq > #
                ceiling, "grey30", "grey50")))#
        table[is.na(table$freq), "freq"] <- 1#
        table <- subset(table, freq * ceiling >= floor)#
    }#
    if (type == "size") {#
        nx <- length(levels(table$x))#
        ny <- length(levels(table$y))#
        p <- ggplot(table, aes_string(x = "x", y = "y", height = "freq", #
            width = "freq", fill = "border")) + geom_tile(colour = "white") + #
            scale_fill_identity() + theme(aspect.ratio = ny/nx)#
    }#
    else {#
        p <- ggplot(table, aes_string(x = "x", y = "y", fill = "freq")) + #
            geom_tile(colour = "white") + scale_fill_gradient2(expression(sign(w[ij])*sqrt(abs(w[ij])))#
, low = "red", mid="white", high = "blue")#
    }#
    p$xlabel <- oldnames[1]#
    p$ylabel <- oldnames[2]#
    p#
}#
#
### Extract necessary components of the fitted model#
y <- fm@y#
X <- getME(fm, "X")#
Z <- BlockZ(fm) #
#
n <- nrow(X)#
p <- ncol(X)#
ngrps <- unname( summary(fm)@ngrps )#
vc <- VarCorr(fm)#
Di <- Diagonal(x = c(vc[[1]], vc[[2]])) / (unname(attr(vc, "sc")))^2#
D  <- kronecker( Diagonal(ngrps), Di )#
#
Aslot <- fm@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.int <- kronecker(Diagonal(ngrps), c(1, 0))#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))
HLMdiag:::.mer_matrices
HLMdiag:::varcomp.mer
vc
bdiag(vc)
fm
kronecker( Diagonal(ngrps), bdiag(vc) )
Di <- bdiag(vc)
D  <- kronecker( Diagonal(ngrps), Di )
dim(D)
D
Aslot <- fm@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.int <- kronecker(Diagonal(ngrps), c(1, 0))#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))
pzdl <- P %*% Z %*% D %*% L.slope#
A.slope <-  crossprod( pzdl )#
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope
pzdl <- P %*% Z %*% D %*% L.int#
A.int <-  crossprod( pzdl )#
B.int <- t(L.int) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.int
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)
fc.int
fc.slope
mean(fc.int)
mean(fc.slope)
s <- 80 # length of rotated residual vector
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
s <- 70 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
s <- 60 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
s <- 60 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
sigma(fm)
Di <- bdiag(vc) / sigma(fm)^2
D  <- kronecker( Diagonal(ngrps), Di )
Aslot <- fm@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.int <- kronecker(Diagonal(ngrps), c(1, 0))#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))#
#
pzdl <- P %*% Z %*% D %*% L.slope#
A.slope <-  crossprod( pzdl )#
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope#
#
pzdl <- P %*% Z %*% D %*% L.int#
A.int <-  crossprod( pzdl )#
B.int <- t(L.int) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.int#
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)#
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)#
#
s <- 60 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
Aslot <- fm@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.int <- kronecker(Diagonal(ngrps), c(1, 0))#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))#
#
pzdl <- P %*% Z %*% D %*% L.slope#
A.slope <-  crossprod( pzdl )#
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope#
#
pzdl <- P %*% Z %*% D %*% L.int#
A.int <-  crossprod( pzdl )#
B.int <- t(L.int) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.int#
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)#
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)#
#
s <- 60 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
s <- 50 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
normsims <- readRDS("../simulations/other radon sims/sim_models/sige2_sigb1/norm_norm_REMLmodels.RDS")
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/minconfounded_chapter/")
normsims <- readRDS("../simulations/other radon sims/sim_models/sige2_sigb1/norm_norm_REMLmodels.RDS")
dir(../simulations/other radon sims/sim_models/)
dir("../simulations/other radon sims/sim_models/")
normsims <- readRDS("../simulations/other radon sims/sim_models/sige2_sigb1/norm_norm_REMLmodels.RDS")
fm <- normsims[[1]]
rm(normsims)
fm
Extract necessary components of the fitted model#
y <- fm@y#
X <- getME(fm, "X")#
Z <- BlockZ(fm) #
#
n <- nrow(X)#
p <- ncol(X)#
ngrps <- unname( summary(fm)@ngrps )#
vc <- VarCorr(fm)#
# Di <- Diagonal(x = c(vc[[1]], vc[[2]])) / (unname(attr(vc, "sc")))^2#
Di <- bdiag(vc) / sigma(fm)^2#
D  <- kronecker( Diagonal(ngrps), Di )
Di
Aslot <- fm@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))#
#
### Rotating the random slope#
L.int <- kronecker(Diagonal(ngrps), c(1, 0))#
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))#
#
pzdl <- P %*% Z %*% D %*% L.slope#
A.slope <-  crossprod( pzdl )#
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope#
#
pzdl <- P %*% Z %*% D %*% L.int#
A.int <-  crossprod( pzdl )#
B.int <- t(L.int) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.int#
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)#
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)#
#
s <- 60 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
ggfluctuation(as.table(reordered.Wt.vmx.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
ggfluctuation(as.table(reordered.Wt.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
s <- 80 # length of rotated residual vector#
### For the random intercept#
W.int <- as.matrix( mcrotate(A = A.int, B = B.int, s = s) )#
W.vmx.int <- varimax( W.int, normalize = FALSE )$loadings#
#
Wt.int <- as.matrix( zapsmall( t(W.int) ) )#
Wt.vmx.int <- as.matrix( zapsmall( t(W.vmx.int) ) )#
#
# colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
colnames(Wt.int) <- colnames(Wt.vmx.int) <- unique( radon$county.name )#
rownames(Wt.int) <- rownames(Wt.vmx.int) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random ints#
rint.var <- diag(B.int) # we could order by this, but fc makes more sense#
#
reordered.Wt.int <- Wt.int[, order(fc.int, decreasing = TRUE)]#
reordered.Wt.vmx.int <- Wt.vmx.int[, order(fc.int, decreasing = TRUE)]#
#
reordered.Wt.int.tform <- sign(reordered.Wt.int) * sqrt(abs(reordered.Wt.int))#
reordered.Wt.vmx.int.tform <- sign(reordered.Wt.vmx.int) * sqrt(abs(reordered.Wt.vmx.int))#
#
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
ggfluctuation(as.table(reordered.Wt.vmx.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
s <- 80 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
fc.int   <- diag(ginv(as.matrix(B.int)) %*% A.int)#
fc.slope <- diag(ginv(as.matrix(B.slope)) %*% A.slope)
s <- 80 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
s <- 60 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
s <- 50 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
s <- 40 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.int))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))
s <- 80 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.slope))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
s <- 80 # length of rotated residual vector#
### For the random slope#
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope, s = s) )#
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings#
#
Wt.slope <- as.matrix( zapsmall( t(W.slope) ) )#
Wt.vmx.slope <- as.matrix( zapsmall( t(W.vmx.slope) ) )#
#
# colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
colnames(Wt.slope) <- colnames(Wt.vmx.slope) <- unique( radon$county.name )#
rownames(Wt.slope) <- rownames(Wt.vmx.slope) <- seq_len(nrow(Wt.slope))#
#
# Pulling off variances of random slopes#
rslope.var <- diag(B.slope) # we could order by this, but fc makes more sense#
#
reordered.Wt.slope <- Wt.slope[, order(fc.slope, decreasing = TRUE)]#
reordered.Wt.vmx.slope <- Wt.vmx.slope[, order(fc.slope, decreasing = TRUE)]#
#
reordered.Wt.slope.tform <- sign(reordered.Wt.slope) * sqrt(abs(reordered.Wt.slope))#
reordered.Wt.vmx.slope.tform <- sign(reordered.Wt.vmx.slope) * sqrt(abs(reordered.Wt.vmx.slope))#
#
ggfluctuation(as.table(reordered.Wt.slope.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
fc.slope
ggfluctuation(as.table(reordered.Wt.int.tform), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s))
ggfluctuation(as.table(reordered.Wt.vmx.int), type = "colour") + #
  theme(axis.text.x = element_text(angle = 90, hjust=1, vjust=.5, size=6, colour="black"),#
    axis.text.y = element_text(size=6, colour="black")) + #
  xlab("County") + ylab("Index of Rotated Residuals") + #
  coord_equal() + #
  theme(panel.margin = unit(0, "lines")) + #
  ggtitle(paste("s = ", s, "(varimax rotation)"))
q("no")
