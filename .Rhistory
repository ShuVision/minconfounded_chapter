qqline
Preliminaries#
library(lme4)#
library(arm)       # for nicer print outs from lmer#
library(ggplot2)#
library(nortest)   # for tests of normality#
library(RcppEigen)#
library(inline)#
#
setwd("~/Documents/Thesis/Dissertation/eresids-chapter/minconfounded_chapter/")#
#
source("../simulations/functions/cpp_functions.R")
Data for the continuous random slope example#
radon <- read.csv("data/radon_for_sims.csv")#
#
# the fitted model#
fm <- lmer(log.radon ~ basement + house.uranium + uranium + (house.uranium | county), data = radon, REML = FALSE)
normsims <- readRDS("../simulations/continuous slope radon sims/sim_models/sige2_sigb1/norm_norm_REMLmodels.RDS")
fm <- normsims[[1]]
fm
rm(normsims)
BlockZ <- function(object) {#
  Z <- getME(object, "Z")#
  grp.size <- table(object@flist)#
  ngrps <- length(grp.size)#
  nranef <- dim(ranef(object)[[1]])[2]#
  base.ord <- seq(from = 1, by = ngrps, length.out = nranef)#
  ord <- base.ord + rep(0:(ngrps - 1), each = nranef)#
  perm.mat <- t(as(ord, "pMatrix"))#
  return(Z %*% perm.mat)#
}#
#
mcrotate <- function(A, B) {#
  r <- rankMatrix(B)#
  B.svd <- svd(B)#
  Cr.diag <- B.svd$d[1:r]#
  Tr <- B.svd$u[, 1:r]#
  A.star <- Diagonal( x = 1 / sqrt(Cr.diag) ) %*% t(Tr) %*% #
    A %*% #
    Tr %*% Diagonal( x = 1 / sqrt(Cr.diag) )#
  A.star.svd <- svd( A.star )#
  W <- Tr %*% Diagonal( x = 1 / sqrt( Cr.diag ) ) %*% A.star.svd$u#
  return(W)#
}
y <- fm@y#
X <- getME(fm, "X")#
Z <- BlockZ(fm) #
#
n <- nrow(X)#
p <- ncol(X)#
ngrps <- unname( summary(fm)@ngrps )#
vc <- VarCorr(fm)#
Di <- Diagonal(x = c(vc[[1]], vc[[2]])) / (unname(attr(vc, "sc")))^2#
D  <- kronecker( Diagonal(ngrps), Di )#
#
Aslot <- .mod@A # ZDZ'#
zdzt <- crossprod( fm@A )#
V  <- Diagonal( n ) + zdzt#
V.chol <- chol( V )#
Vinv  <- chol2inv( V.chol ) #
#
XVXinv <- solve( t(X) %*% Vinv %*% X )#
VinvX  <- Vinv %*% X#
M      <- VinvX %*% XVXinv %*% t(VinvX)#
P      <- cxxmatsub(as.matrix(Vinv), as.matrix(M))
L.slope <- kronecker(Diagonal(ngrps), c(0, 1))
pzdl <- P %*% Z %*% D %*% L.slope
A.slope <-  crossprod( pzdl )
B.slope <- t(L.slope) %*% D %*% t(Z) %*% P %*% Z %*% D %*% L.slope
W.slope <- mcrotate(A = A.slope, B = B.slope)
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
W.slope <- as.matrix( mcrotate(A = A.slope, B = B.slope) )
W.vmx.slope <- varimax( W.slope, normalize = FALSE )$loadings
head(radon)
ggfluctuation <- function (table, type = "size", floor = 0, ceiling = max(table$freq, #
    na.rm = TRUE)) #
{#
    .Deprecated()#
    if (is.table(table)) #
        table <- as.data.frame(t(table))#
    oldnames <- names(table)#
    names(table) <- c("x", "y", "result")#
    table <- transform(table, x = as.factor(x), y = as.factor(y), #
        freq = result)#
    if (type == "size") {#
        table <- transform(table, freq = sqrt(pmin(freq, ceiling)/ceiling), #
            border = ifelse(is.na(freq), "grey90", ifelse(freq > #
                ceiling, "grey30", "grey50")))#
        table[is.na(table$freq), "freq"] <- 1#
        table <- subset(table, freq * ceiling >= floor)#
    }#
    if (type == "size") {#
        nx <- length(levels(table$x))#
        ny <- length(levels(table$y))#
        p <- ggplot(table, aes_string(x = "x", y = "y", height = "freq", #
            width = "freq", fill = "border")) + geom_tile(colour = "white") + #
            scale_fill_identity() + theme(aspect.ratio = ny/nx)#
    }#
    else {#
        p <- ggplot(table, aes_string(x = "x", y = "y", fill = "freq")) + #
            geom_tile(colour = "white") + scale_fill_gradient2(expression(sign(w[ij])*sqrt(abs(w[ij])))#
, low = "red", mid="white", high = "blue")#
    }#
    p$xlabel <- oldnames[1]#
    p$ylabel <- oldnames[2]#
    p#
}
image(W.slope)
image(W.vmx.slope)
W.slope
rsv <- ranef(fm, postVar=TRUE)#
rslope.var <- apply(attr(rsv[[1]], "postVar"), 3, function(x) x[2,2])
ranef(fm, postVar=TRUE)
fm
ranef(fm, postVar=TRUE)
library(arm)
ranef(fm, postVar=TRUE)
library(lme4)
ranef(fm, postVar=TRUE)
